#include <stdio.h>
#include <math.h>
#include <stdint.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

typedef struct {
    // Electrical
    double Rs, Rr, Lls, Llr, Lm, Ls, Lr;
    // Mechanical
    int    P;
    double J, B;
    // Thermal
    double Cth_s, Cth_r, R_sa, R_ra, R_sr, k_core;
    // Supply
    double V_ll_rms, f_e;
    // Load
    double T_load0, T_load_final, t_load_ramp;
    // Ambient
    double T_amb;
} Params;

typedef struct {
    // States
    double lds, lqs, ldr, lqr;  // flux linkages
    double wr;                  // rotor speed (rad/s)
    double Ts, Tr;              // stator & rotor temps (°C)
    double t;                   // time (s)
} State;

// ================= MRAS STATES =================
static double wr_hat = 0.0;     // Estimated rotor speed
static double xi_mras = 0.0;    // MRAS integrator

// ================= FAULT INDEX STATES =================
static double Te_avg = 0.0;
static double Te_var = 0.0;

static void im_derivs(const Params* p, const State* x,
                      // outputs: derivatives
                      double* dlds, double* dlqs, double* dldr, double* dlqr,
                      double* dwr,  double* dTs,  double* dTr,
                      // also compute these for logging
                      double* ids,  double* iqs,  double* idr, double* iqr,
                      double* Te,   double* Tload, double* MFI, double* EFI, double* TFI)
{
    

     // -------- CONSTANTS --------
    const double ws = 2.0 * M_PI * p->f_e;
    const double dt = 1e-4;

    // Currents from flux linkages 
    const double det = p->Ls * p->Lr - p->Lm * p->Lm;
    const double ids_ = (p->Lr * x->lds - p->Lm * x->ldr) / det;
    const double iqs_ = (p->Lr * x->lqs - p->Lm * x->lqr) / det;
    const double idr_ = (-p->Lm * x->lds + p->Ls * x->ldr) / det;
    const double iqr_ = (-p->Lm * x->lqs + p->Ls * x->lqr) / det;

    // Supply voltages (dq, synchronous frame) — constant Vd, zero Vq
    const double V_ph_rms  = p->V_ll_rms / sqrt(3.0);
    const double V_ph_peak = sqrt(2.0) * V_ph_rms;
    const double vds = V_ph_peak;
    const double vqs = 0.0;

    const double L_id = 200.0;
    const double L_iq = 200.0;

    double id_meas = ids_;
    double iq_meas = iqs_;

    double e_id = id_meas - ids_;
    double e_iq = iq_meas - iqs_;

    // Flux derivatives
    *dlds = vds - p->Rs * ids_ + ws * x->lqs + L_id * e_id;
    *dlqs = vqs - p->Rs * iqs_ - ws * x->lds + L_iq * e_iq;

    // =========================================================
    // MRAS (STATOR-FLUX–BASED SPEED ESTIMATION)
    // ε = λds_ref*λqs_hat − λqs_ref*λds_hat
    // d(ω̂r)/dt = γ * ε
    // =========================================================

    // Adaptive model (from rotor currents)
    const double lds_hat = p->Lm * idr_;
    const double lqs_hat = p->Lm * iqr_;

    const double eps_mras = (x->lds * lqs_hat) - (x->lqs * lds_hat);

    const double gamma_mras = 200.0;
    xi_mras += gamma_mras * eps_mras * dt;
    wr_hat = xi_mras;

    if (wr_hat < 0.0) wr_hat = 0.0;
    if (wr_hat > ws)  wr_hat = ws;

    // Slip speed uses MRAS estimate
    const double slip_speed = ws - wr_hat;

    *dldr = -p->Rr * idr_ + slip_speed * x->lqr;
    *dlqr = -p->Rr * iqr_ - slip_speed * x->ldr;

    // Electromagnetic torque
    const double Te_ = 1.5 * (p->P / 2.0) * (x->lds * iqs_ - x->lqs * ids_);

    // Load torque profile (ramp)
    double Tload_;
    if (x->t < p->t_load_ramp) {
        Tload_ = p->T_load0 + (p->T_load_final - p->T_load0) * (x->t / p->t_load_ramp);
    } else {
        Tload_ = p->T_load_final;
    }

    // Mechanical dynamics
    *dwr = (Te_ - Tload_ - p->B * x->wr) / p->J;

    // Losses
    const double Psc  = 3.0 * p->Rs * (ids_*ids_ + iqs_*iqs_);
    const double Prc  = 3.0 * p->Rr * (idr_*idr_ + iqr_*iqr_);
    // simple core loss model (scaled with V and frequency)
    const double Pcore = p->k_core * (V_ph_rms*V_ph_rms) * (p->f_e/50.0)
                       * (1.0 + 0.1*sqrt(x->lds*x->lds + x->lqs*x->lqs));
    const double Pfw   = p->B * x->wr * x->wr;

    // Thermal dynamics
    *dTs = (Psc + Pcore - (x->Ts - p->T_amb) / p->R_sa - (x->Ts - x->Tr) / p->R_sr) / p->Cth_s;
    *dTr = (Prc + Pfw   - (x->Tr - x->Ts) / p->R_sr - (x->Tr - p->T_amb) / p->R_ra) / p->Cth_r;

    // =========================================================
    // ================= FAULT INDICES =========================
    // =========================================================

    // -------- Mechanical Fault Index (Torque Ripple) --------
    const double alpha_m = 0.01;
    const double eps = 1e-6;

    Te_avg += alpha_m * (Te_ - Te_avg);
    double Te_ripple = Te_ - Te_avg;
    Te_var += alpha_m * (Te_ripple * Te_ripple - Te_var);

    *MFI = sqrt(Te_var) / (fabs(Te_avg) + eps);

    // -------- Thermal Fault Index (Temperature Stress) --------
    const double T_max = 180.0;
    *TFI = (x->Ts - p->T_amb) / (T_max - p->T_amb);
    if (*TFI < 0.0) *TFI = 0.0;
    if (*TFI > 1.5) *TFI = 1.5;

    // -------- Electrical Fault Index (Current Magnitude) -----
    const double I_nom = 10.0;
    double I_mag = sqrt(ids_ * ids_ + iqs_ * iqs_);
    *EFI = I_mag / I_nom;

    // Copies for logging
    if (ids)  *ids  = ids_;
    if (iqs)  *iqs  = iqs_;
    if (idr)  *idr  = idr_;
    if (iqr)  *iqr  = iqr_;
    if (Te)   *Te   = Te_;
    if (Tload)*Tload= Tload_;
}

int main(void)
{
    // ---- Parameters (same as your Python) ----
    Params p = {
        // Electrical
        .Rs=0.435, .Rr=0.816, .Lls=0.002, .Llr=0.002, .Lm=0.0693,
        // Ls/Lr computed below
        // Mechanical
        .P=4, .J=0.089, .B=0.0005,
        // Thermal
        .Cth_s=4000.0, .Cth_r=3000.0, .R_sa=0.5, .R_ra=0.7, .R_sr=0.2, .k_core=5.0,
        // Supply
        .V_ll_rms=400.0, .f_e=50.0,
        // Load profile
        .T_load0=0.0, .T_load_final=50.0, .t_load_ramp=0.5,
        // Ambient
        .T_amb=25.0
    };
    p.Ls = p.Lls + p.Lm;
    p.Lr = p.Llr + p.Lm;

    // ---- Initial state ----
    State x = {0};
    x.lds = 0.0; x.lqs = 0.0; x.ldr = 0.0; x.lqr = 0.0;
    x.wr  = 0.0; x.Ts  = p.T_amb; x.Tr  = p.T_amb; x.t = 0.0;

    // ---- Integration settings ----
    const double t_end = 1.0;       // seconds
    const double dt    = 1e-4;      // 100 µs step (stable & fast on PC)
    const int    print_every = (int)lrint(1e-3 / dt); // print every 1 ms
    int          k = 0;

    // ---- CSV header ----
    printf("t,i_ds,i_qs,i_dr,i_qr,Te,T_load,w_r,T_s,T_r,MFI,TFI,EFI\n");

    // ---- Time loop ----
    while (x.t <= t_end + 1e-12) {
        // Derivatives + log vars at current state
        double dlds, dlqs, dldr, dlqr, dwr, dTs, dTr;
        double ids, iqs, idr, iqr, Te, Tload;
            double MFI, TFI, EFI;
        im_derivs(&p, &x, &dlds, &dlqs, &dldr, &dlqr, 
            &dwr, &dTs, &dTr,
            &ids, &iqs, &idr, &iqr, &Te, &Tload, 
            &MFI, &TFI, &EFI);

        // Euler step
        x.lds += dlds * dt;
        x.lqs += dlqs * dt;
        x.ldr += dldr * dt;
        x.lqr += dlqr * dt;
        x.wr  += dwr  * dt;
        x.Ts  += dTs  * dt;
        x.Tr  += dTr  * dt;
        x.t   += dt;

        // Print every 1 ms (reduce file size)
        if ((k % print_every) == 0) {
            printf("%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f\n",
                   x.t, ids, iqs, idr, iqr, Te, Tload, x.wr, x.Ts, x.Tr,MFI,TFI,EFI);
        }
        ++k;
    }

    return 0;
}
